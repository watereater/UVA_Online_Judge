Question 441 gives the user a series of inputs which consist of a list of strictly
increasing numbers. From the list the user much construct all combinations of size six and print them in increasing order.

How to solve using c++: If you think about a combination, it is just a more restricted form of a permutation. If you were to generate all possible permutations and you only take the first six numbers then you would be able to create all possible combinations. Of course this method is redundant and has a run time of O(N!). To decrease the run time you have to realize that in a combination, order matters and that the output is limited in size. To achieve a pseudo combination you can run a permutation of 0s and 1s. You first create a vector of 6 zeros. Then for each additional number that is inputted after the sixth number you add a 1 to the end of the vector. You then run next_permutation until the code finishes. You only print if the index contains a zero.

How to solve using java: To understand how to solve using java you should first read how to solve using c++. Unfortunately, when writing the code in java there is no next_permutation or any other built in algorithm that I know of. So what I tried to do was simulate next_permutation. To permute through a list of zeros and ones I used a series of bitwise operators i.e...
Take a list {1, 2, 3, 4} and say that you want all combinations of size 2;
pr = push right; pl = push left; o = mask ones
0011 -> 12: 3 >> 1 = 1 (pl = 1 o = 1); 1 >> 1 = 0; 0 << 1 = 0; 0|2 = 2; 2 | 1 = 3 (o = 1)
0101 -> 13: 3 >> 1 = 2; 2 << 1 = 4; 4 | 2 = 6;
0110 -> 14: 6 >> 1 = 3 (pl = 1); 3 >> 1 = 1 (pl = 2 o = 1); 1 >> 1 = 0; 0 << 1 = 0;
			0 | 2 = 2; 2 << 2 = 8(pr = 2); 8 | 1 = 9 (o = 1);
1001 -> 23
1010 -> 24
1100 -> 34
10001 ends

look at java code for more clarity.

Note:
* there should be an empty line between each series of output
* there should not be an empty line at the end of the last output